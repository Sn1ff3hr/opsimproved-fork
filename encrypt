# Consolidated encryption, worker, and hCaptcha code
This file aggregates the complete contents of key files for audit.

## fabs/js/cojoin.js
```javascript
/**
 * fabs/js/cojoin.js
 *
 * This script contains the logic for both the Contact Us and Join Us forms.
 * It handles form submission, security checks (honeypot, malicious code),
 * and the dynamic form fields for the Join form.
 */

function initCojoinForms() {
  const contactForm = document.getElementById('contactForm');
  const joinForm = document.getElementById('joinForm');

  window.antibot.loadRecaptcha();

  if (contactForm && !contactForm.dataset.cojoinInitialized) {
    window.antibot.injectFormHoneypot(contactForm);
    contactForm.addEventListener('submit', handleContactSubmit);
    contactForm.dataset.cojoinInitialized = 'true';
  }

  if (joinForm && !joinForm.dataset.cojoinInitialized) {
    window.antibot.injectFormHoneypot(joinForm);
    joinForm.addEventListener('submit', handleJoinSubmit);
    joinForm.dataset.cojoinInitialized = 'true';
    initJoinForm();
  }


  /**
   * Retrieves an AES-GCM key generated by a server-side KMS/HSM.
   * The server is responsible for managing the lifecycle of this key
   * in alignment with NIST and PCI DSS requirements.
   * @returns {Promise<CryptoKey>} The imported AES-GCM key.
   */
  async function getAesKeyFromKms() {
    // ====================================================================================
    // IMPORTANT: AES Key Service Endpoint
    // Replace the URL below with your actual endpoint for fetching the AES key.
    // ====================================================================================
    const res = await fetch('https://your-server.example.com/kms/aes-key');
    const { key } = await res.json(); // base64 encoded key material
    const rawKey = base64ToArrayBuffer(key);
    return crypto.subtle.importKey('raw', rawKey, { name: 'AES-GCM' }, false, ['encrypt']);
  }

  /**
   * Requests a short-lived bearer token from the server. The token is
   * returned as an AES-GCM encrypted blob alongside its IV so it can be
   * decrypted by the Cloudflare worker.
   * @returns {Promise<{token: string, iv: string}>}
   */
  async function getBearerToken() {
    // ====================================================================================
    // IMPORTANT: Auth Token Service Endpoint
    // Replace the URL below with your actual endpoint for fetching the auth token.
    // ====================================================================================
    const res = await fetch('https://your-server.example.com/auth/token');
    return res.json(); // { token: base64CipherText, iv: base64IV }
  }

  function arrayBufferToBase64(buffer) {
    return btoa(String.fromCharCode(...new Uint8Array(buffer)));
  }

  function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  /**
   * Simulated function to send data to a Cloudflare worker.
   * This is where you would implement your data encryption logic before sending.
   * @param {object} data The sanitized form data to send.
   */
  async function sendToCloudflareWorker(data) {
    console.log("Data is clean. Encrypting and sending to Cloudflare worker...", data);
    try {
      // Retrieve managed key and short-lived token from the server
      const [aesKey, tokenInfo] = await Promise.all([
        getAesKeyFromKms(),
        getBearerToken(),
      ]);

      // Encrypt payload using AES-GCM
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoder = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        aesKey,
        encoder.encode(JSON.stringify(data))
      );

      const payload = {
        iv: Array.from(iv),
        payload: arrayBufferToBase64(encrypted),
      };

      // Compose Authorization header as Bearer <iv>.<cipher>
      const authHeader = `Bearer ${tokenInfo.iv}.${tokenInfo.token}`;

      // ====================================================================================
      // IMPORTANT: Cloudflare Worker API Endpoint
      // Replace the URL below with your actual Cloudflare Worker API endpoint.
      // ====================================================================================
      const response = await fetch('https://your-cloudflare-worker.example.com/api', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': authHeader,
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        console.log('Data successfully sent and processed by Cloudflare worker.');
      } else {
        console.error('Failed to send data to Cloudflare worker.');
      }
    } catch (error) {
      console.error('Network error or worker unreachable:', error);
    }
  }

  /**
   * Contact Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleContactSubmit(e) {
    e.preventDefault();

    const form = e.target;
    // 1. Honeypot check
    if (window.antibot.isHoneypotTriggered(form)) {
      console.warn('Honeypot filled. Blocking form submission.');
      form.reset();
      return;
    }
    const formData = new FormData(form);

    const data = Object.fromEntries(formData.entries());

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = window.appUtils.sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }

    // Obtain reCAPTCHA token
    try {
      sanitizedData.recaptchaToken = await window.antibot.getRecaptchaToken('contact');
    } catch (err) {
      alert('Security check failed.');
      return;
    }

    // 3. Prepare and send sanitized data to worker
    alert('Contact form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Join Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleJoinSubmit(e) {
    e.preventDefault();

    const form = e.target;
    // 1. Honeypot check
    if (window.antibot.isHoneypotTriggered(form)) {
      console.warn('Honeypot filled. Blocking form submission.');
      form.reset();
      return;
    }
    const formData = new FormData(form);

    const data = Object.fromEntries(formData.entries());

    // Check that all dynamic sections are 'accepted' or empty
    const formSections = document.querySelectorAll('.form-section[data-section]');
    for (const section of formSections) {
      const inputs = section.querySelectorAll('input[type=text]');
      if (inputs.length > 0 && !section.classList.contains('completed')) {
        alert(`Please accept your entries in "${section.querySelector('h2').textContent}" or remove them.`);
        return;
      }
    }

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = window.appUtils.sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }

    // Obtain reCAPTCHA token
    try {
      sanitizedData.recaptchaToken = await window.antibot.getRecaptchaToken('join');
    } catch (err) {
      alert('Security check failed.');
      return;
    }

    // 3. Prepare and send sanitized data to worker
    alert('Join form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    resetJoinFormState();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Initializes event listeners for the Join Us form's dynamic sections.
   */
  function initJoinForm() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      const addBtn = section.querySelector('.circle-btn.add');
      const removeBtn = section.querySelector('.circle-btn.remove');
      const acceptBtn = section.querySelector('.accept-btn');
      const editBtn = section.querySelector('.edit-btn');
      const inputsContainer = section.querySelector('.inputs');

      if (addBtn) {
        addBtn.addEventListener('click', () => {
          let field;
          if (section.dataset.section === 'Experience') {
            const count = inputsContainer.querySelectorAll('textarea').length + 1;
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = `tell us about your Experience ${count}`;
          } else if (section.dataset.section === 'Continued Education') {
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = 'Online Courses, Seminars, Webinars with Completion Certification';
          } else {
            field = document.createElement('input');
            field.type = 'text';
            field.placeholder = `Enter ${section.querySelector('h2').textContent.toLowerCase()}`;
          }
          inputsContainer.appendChild(field);
          field.focus();
        });
      }

      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          if (!section.classList.contains('completed')) {
            if (inputsContainer.lastElementChild) {
              inputsContainer.removeChild(inputsContainer.lastElementChild);
            }
          }
        });
      }

      if (acceptBtn) {
        acceptBtn.addEventListener('click', () => {
          const inputs = inputsContainer.querySelectorAll('input[type=text], textarea');
          if (inputs.length === 0) {
            alert('Add at least one entry.');
            return;
          }
          for (const input of inputs) {
            if (!input.value.trim()) {
              alert('Please fill out all fields before accepting.');
              return;
            }
          }
          toggleSectionState(section, true);
        });
      }

      if (editBtn) {
        editBtn.addEventListener('click', () => {
          toggleSectionState(section, false);
        });
      }
    });
  }

  /**
   * Resets the Join Us form to its initial state after submission.
   */
  function resetJoinFormState() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      toggleSectionState(section, false);
      const inputsContainer = section.querySelector('.inputs');
      inputsContainer.innerHTML = '';
    });
  }

  /**
   * Toggles the state of a dynamic form section (accepted/editable).
   * @param {HTMLElement} section The form section element.
   * @param {boolean} accepted True to lock the section, false to unlock.
   */
  function toggleSectionState(section, accepted) {
    const inputs = section.querySelectorAll('input[type=text], textarea');
    const acceptBtn = section.querySelector('.accept-btn');
    const editBtn = section.querySelector('.edit-btn');
    const addBtn = section.querySelector('.circle-btn.add');
    const removeBtn = section.querySelector('.circle-btn.remove');

    inputs.forEach(input => input.disabled = accepted);

    if (accepted) {
      if (acceptBtn) acceptBtn.style.display = 'none';
      if (editBtn) editBtn.style.display = 'inline-block';
      if (addBtn) addBtn.disabled = true;
      if (removeBtn) removeBtn.disabled = true;
      section.classList.add('completed');
    } else {
      if (acceptBtn) acceptBtn.style.display = 'inline-block';
      if (editBtn) editBtn.style.display = 'none';
      if (addBtn) addBtn.disabled = false;
      if (removeBtn) removeBtn.disabled = false;
      section.classList.remove('completed');
    }
  }
}

window.initCojoinForms = initCojoinForms;
document.addEventListener('DOMContentLoaded', initCojoinForms);
```

## worker/secureWorker.js
```javascript
/**
 * Verifies the hCaptcha token by sending it to the hCaptcha API.
 * @param {string} token The hCaptcha token from the client.
 * @param {string} secret The hCaptcha secret key from environment variables.
 * @returns {Promise<boolean>} True if the token is valid, false otherwise.
 */
async function verifyCaptcha(token, secret) {
  if (!token) {
    console.warn('CAPTCHA verification failed: No token provided.');
    return false;
  }
  if (!secret) {
    console.error('FATAL: HCAPTCHA_SECRET_KEY is not set in worker environment.');
    // In a real scenario, this should trigger an alert for the admin.
    return false;
  }

  const formData = new URLSearchParams();
  formData.append('secret', secret);
  formData.append('response', token);
  // formData.append('remoteip', remoteIp); // Optional: pass user's IP

  try {
    const response = await fetch('https://api.hcaptcha.com/siteverify', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: formData,
    });

    const result = await response.json();
    if (!result.success) {
      console.warn('CAPTCHA verification failed:', result['error-codes']);
    }
    return result.success;
  } catch (error) {
    console.error('Error during hCaptcha verification request:', error);
    return false;
  }
}

export default {
  async fetch(request, env) {
    const auth = request.headers.get('Authorization') || '';
    const match = auth.match(/^Bearer ([^.]+)\.([^.]+)$/);
    if (!match) {
      console.warn('Unauthorized request: missing or malformed token');
      return new Response('Unauthorized', { status: 401 });
    }

    try {
      const tokenIv = new Uint8Array(base64ToArrayBuffer(match[1]));
      const tokenCipher = new Uint8Array(base64ToArrayBuffer(match[2]));
      const key = await crypto.subtle.importKey(
        'raw',
        base64ToArrayBuffer(env.AES_KEY),
        { name: 'AES-GCM' },
        false,
        ['decrypt']
      );
      const decoder = new TextDecoder();
      const tokenBuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: tokenIv }, key, tokenCipher);
      const tokenData = JSON.parse(decoder.decode(tokenBuf));
      if (tokenData.exp <= Date.now()) {
        console.warn('Unauthorized request: expired token');
        return new Response('Unauthorized', { status: 401 });
      }

      const body = await request.json();
      const payloadIv = new Uint8Array(body.iv);
      const payloadCipher = new Uint8Array(base64ToArrayBuffer(body.payload));
      const decryptedBuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: payloadIv }, key, payloadCipher);
      const payload = JSON.parse(decoder.decode(decryptedBuf));

      // --- CAPTCHA Verification Step ---
      const captchaToken = payload['h-captcha-response'];
      const isCaptchaValid = await verifyCaptcha(captchaToken, env.HCAPTCHA_SECRET_KEY);

      if (!isCaptchaValid) {
        console.warn('Unauthorized request: invalid CAPTCHA');
        return new Response('Unauthorized: Invalid CAPTCHA', { status: 401 });
      }

      // If captcha is valid, proceed with processing the payload.
      // (Actual data processing logic would go here)
      console.log('CAPTCHA verified. Payload received:', payload);

      return new Response(JSON.stringify({ status: 'success', received: payload }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
    } catch (err) {
      console.warn('Unauthorized request: invalid token or payload', err);
      return new Response('Unauthorized', { status: 401 });
    }
  }
};

function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes.buffer;
}
```

## worker/testRunner.js
```javascript
/**
 * Environment bindings required for this Worker.
 *
 * Configure these in `wrangler.toml` or via `wrangler secret put` so the
 * referenced `env.*` variables resolve at runtime:
 *
 * - `APPS_SCRIPT_URL` **(secret)**: Webhook that receives test results. Used in
 *   `notify` when posting `fetch(env.APPS_SCRIPT_URL)`.
 * - `SECURITY_EMAIL`: Address for MailChannels alerts. Consumed by
 *   `sendEmail`.
 * - `PRIVATE_KEY` **(secret)**: PEM key for RSA-PSS SHA-256 signing in
 *   `signPayload`.
 * - `AUDIT_LOG`: KV namespace binding storing the `time | date | type | ip`
 *   audit trail accessed by `logEvent` and `logAlertFailure`.
 */
let tests;

async function runAll(env, ip) {
  if (!tests) {
    ({ default: tests } = await import('../tests/bundle.js'));
  }
  const results = [];
  for (const testFn of tests) {
    const name = testFn.name || 'anonymous';
    try {
      await testFn();
      results.push({ name, status: 'pass' });
    } catch (err) {
      const message = err && err.message ? err.message : String(err);
      let type = 'failure';
      if (/intrusion/i.test(message)) type = 'intrusion';
      else if (/injection/i.test(message)) type = 'injection';
      else if (err instanceof Error) type = 'error';
      results.push({ name, status: 'fail', error: message, type });
      await notify(env, type, ip, { name, message });
    }
  }
  return results;
}

async function notify(env, type, ip, detail) {
  const now = new Date();
  const payload = { timestamp: now.toISOString(), type, ip, detail };
  const signature = await signPayload(payload, env.PRIVATE_KEY);
  payload.signature = signature;
  const body = JSON.stringify(payload);

  const operations = [
    fetch(env.APPS_SCRIPT_URL || 'https://Apps Script here', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body
    }),
    sendEmail(env.SECURITY_EMAIL, body),
    logEvent(env, type, ip, now)
  ];

  const results = await Promise.allSettled(operations);
  for (const r of results) {
    if (r.status === 'rejected') {
      await logAlertFailure(env, ip, r.reason);
    }
  }
}

async function logEvent(env, type, ip, now) {
  if (!env.AUDIT_LOG) {
    console.warn('AUDIT_LOG not configured; event not logged');
    return;
  }
  const row = `${now.toTimeString().split(' ')[0]} | ${now.toISOString().split('T')[0]} | ${type} | ${ip}`;
  await env.AUDIT_LOG.put(now.toISOString(), row);
}

async function logAlertFailure(env, ip, error) {
  console.warn('Alert dispatch failed:', error);
  if (!env.AUDIT_LOG) {
    console.warn('AUDIT_LOG not configured; alert_failure not logged');
    return;
  }
  const now = new Date();
  const row = `${now.toTimeString().split(' ')[0]} | ${now.toISOString().split('T')[0]} | alert_failure | ${ip}`;
  try {
    await env.AUDIT_LOG.put(`${now.toISOString()}-alert_failure`, row);
  } catch (err) {
    console.warn('Failed to log alert_failure:', err);
  }
}

async function sendEmail(address, content) {
  if (!address) return;
  return fetch('https://api.mailchannels.net/tx/v1/send', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      personalizations: [{ to: [{ email: address }] }],
      from: { email: 'noreply@example.com' },
      subject: 'Security Test Alert',
      content: [{ type: 'text/plain', value: content }]
    })
  });
}

async function signPayload(data, pemKey) {
  if (!pemKey) return '';
  const encoder = new TextEncoder();
  const der = pemKey.replace(/-----(BEGIN|END) PRIVATE KEY-----/g, '').replace(/\s+/g, '');
  const binary = atob(der);
  const buffer = new Uint8Array([...binary].map(c => c.charCodeAt(0))).buffer;
  const key = await crypto.subtle.importKey(
    'pkcs8',
    buffer,
    { name: 'RSA-PSS', hash: 'SHA-256' },
    false,
    ['sign']
  );
  const signature = await crypto.subtle.sign(
    { name: 'RSA-PSS', saltLength: 32 },
    key,
    encoder.encode(JSON.stringify(data))
  );
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
}

export { notify, logAlertFailure };

export default {
  async scheduled(event, env, ctx) {
    const ip = event.request?.headers.get('cf-connecting-ip') || 'n/a';
    await runAll(env, ip);
  },
  async fetch(request, env, ctx) {
    if (request.method === 'POST') {
      const ip = request.headers.get('cf-connecting-ip') || 'n/a';
      ctx.waitUntil(runAll(env, ip));
      return new Response('Tests triggered', { status: 202 });
    }
    return new Response('OK');
  }
};
```

## server.js
```javascript
const express = require('express');
const session = require('express-session');
const crypto = require('crypto');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const cookie = require('cookie');

const app = express();

app.use(helmet());
app.use(express.json());
const isProduction = process.env.NODE_ENV === 'production';
const sessionSecret = process.env.SESSION_SECRET;

if (isProduction) {
  app.set('trust proxy', 1); // Trust the first proxy
}

if (isProduction && (!sessionSecret || sessionSecret === 'dev-secret')) {
  console.error('FATAL ERROR: SESSION_SECRET is not set in production.');
  process.exit(1);
}

app.use(
  session({
    secret: sessionSecret || 'dev-secret',
    resave: false,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      sameSite: 'strict',
      secure: isProduction,
    },
  })
);

function generateToken() {
  return crypto.randomBytes(32).toString('hex');
}

function generateNonce() {
  const array = new Uint8Array(16); // 128-bit nonce
  crypto.webcrypto.getRandomValues(array);
  return Buffer.from(array).toString('hex');
}

function requireNonce(req, res, next) {
  const cookies = cookie.parse(req.headers.cookie || '');
  const clientNonce = cookies.nonce;
  const sessionNonce = req.session.nonce;

  if (
    !clientNonce ||
    !sessionNonce ||
    clientNonce !== sessionNonce.value ||
    Date.now() > sessionNonce.expires
  ) {
    return res.status(403).json({ error: 'Invalid nonce' });
  }

  const newNonce = generateNonce();
  req.session.nonce = { value: newNonce, expires: Date.now() + 10 * 60 * 1000 };
  res.cookie('nonce', newNonce, {
    httpOnly: true,
    sameSite: 'strict',
    secure: isProduction,
  });

  next();
}

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', apiLimiter);

app.post('/api/session', (req, res) => {
  const nonce = generateNonce();
  req.session.nonce = { value: nonce, expires: Date.now() + 10 * 60 * 1000 };
  res.cookie('nonce', nonce, {
    httpOnly: true,
    sameSite: 'strict',
    secure: isProduction,
  });
  res.status(204).end();
});

app.use('/api/', requireNonce);

app.get('/api/csrf-token', (req, res) => {
  const token = generateToken();
  req.session.csrfToken = { value: token, expires: Date.now() + 10 * 60 * 1000 };
  res.json({ token });
});

const contactValidation = [
  body('name').trim().isLength({ min: 1 }).escape(),
  body('email').isEmail().normalizeEmail(),
  body('message').trim().isLength({ min: 1 }).escape(),
];

app.post('/api/contact', contactValidation, (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { csrfToken } = req.body;
  const sessionToken = req.session.csrfToken;
  if (
    !csrfToken ||
    !sessionToken ||
    sessionToken.value !== csrfToken ||
    Date.now() > sessionToken.expires
  ) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  const newToken = generateToken();
  req.session.csrfToken = { value: newToken, expires: Date.now() + 10 * 60 * 1000 };
  res.set('X-CSRF-Token', newToken);
  // Process data here (omitted)
  res.json({ ok: true });
});

// Chatbot message handling with nonce validation
app.post('/api/chat/reset', (req, res) => {
  req.session.chatNonce = null;
  res.json({ ok: true });
});

app.post('/api/chat', (req, res) => {
  const { message, nonce } = req.body || {};
  if (!nonce || typeof nonce !== 'string') {
    return res.status(400).json({ error: 'Missing nonce' });
  }

  const now = Date.now();
  const sessionNonce = req.session.chatNonce;
  if (!sessionNonce || sessionNonce.expires < now) {
    req.session.chatNonce = { value: nonce, expires: now + 10 * 60 * 1000 };
  } else if (sessionNonce.value !== nonce) {
    return res.status(403).json({ error: 'Invalid nonce' });
  } else {
    // refresh expiry
    req.session.chatNonce.expires = now + 10 * 60 * 1000;
  }

  // Placeholder response; integrate with chatbot backend here.
  res.json({ reply: 'ok', echoed: message });
});

module.exports = app;

if (require.main === module) {
  const port = process.env.PORT || 3000;
  app.listen(port, () => {
    console.log(`Server running on port ${port}`);
  });
}
```

## wrangler-nonce.toml
```toml
name = "nonce-worker"
main = "worker/nonceWorker.js"
compatibility_date = "2024-06-20"

[[kv_namespaces]]
binding = "USED_NONCES"
# Replace with your KV namespace ID in production.
id = "your_used_nonces_namespace_id"
```

## js/antibot.js
```javascript
(function(){
  const SITE_KEY = '6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI'; // Google test key
  const templates = {};

  // Preload honeypot templates
  fetch('security/honeypots.html')
    .then(res => res.text())
    .then(html => {
      const t = document.createElement('template');
      t.innerHTML = html;
      templates.form = t.content.querySelector('#form-honeypot');
      templates.chat = t.content.querySelector('#chat-honeypot');
    })
    .catch(()=>{});

  function loadRecaptcha(){
    return new Promise((resolve, reject) => {
      if (window.grecaptcha){
        return resolve(window.grecaptcha);
      }
      const script = document.createElement('script');
      script.id = 'recaptcha-script';
      script.src = `https://www.google.com/recaptcha/api.js?render=${SITE_KEY}`;
      script.async = true;
      script.defer = true;
      script.onload = () => resolve(window.grecaptcha);
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  async function getRecaptchaToken(action='submit'){
    const grecaptcha = await loadRecaptcha();
    return grecaptcha.execute(SITE_KEY, { action });
  }

  function injectFormHoneypot(form){
    if(!form) return;
    if(templates.form){
      form.appendChild(templates.form.content.cloneNode(true));
    } else {
      const div = document.createElement('div');
      div.hidden = true;
      const input = document.createElement('input');
      input.type = 'text';
      input.id = 'hp_text';
      input.name = 'hp_text';
      div.appendChild(input);
      form.appendChild(div);
    }
  }

  function injectChatbotHoneypot(form){
    if(!form) return;
    if(templates.chat){
      form.appendChild(templates.chat.content.cloneNode(true));
    } else {
      const div = document.createElement('div');
      div.hidden = true;
      const text = document.createElement('input');
      text.type = 'text';
      text.id = 'hp_text';
      text.name = 'hp_text';
      const check = document.createElement('input');
      check.type = 'checkbox';
      check.id = 'hp_check';
      check.name = 'hp_check';
      div.appendChild(text);
      div.appendChild(check);
      form.appendChild(div);
    }
  }

  function isHoneypotTriggered(root){
    const text = root ? root.querySelector('#hp_text') : null;
    const check = root ? root.querySelector('#hp_check') : null;
    return (text && text.value.trim() !== '') || (check && check.checked);
  }

  window.antibot = {
    loadRecaptcha,
    getRecaptchaToken,
    injectFormHoneypot,
    injectChatbotHoneypot,
    isHoneypotTriggered
  };
})();
```

## fabs/js/chattia.js
```javascript
(function(){
  const WORKER_CHAT_URL = 'https://your-cloudflare-worker.example.com/chat';
  const WORKER_END_SESSION_URL = 'https://your-cloudflare-worker.example.com/end-session';
  const WORKER_HONEYPOT_URL = 'https://your-cloudflare-worker.example.com/honeypot-trip';
  const INACTIVITY_LIMIT_MS = window.CHATBOT_INACTIVITY_MS || 120000;
  let container, log, form, input, send, closeBtn, minimizeBtn, openBtn;
  let langCtrl, themeCtrl, brand, hpText, hpCheck;
  let outsideClickHandler, escKeyHandler, inactivityTimer;
  function resetInactivityTimer(){
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(()=>{ closeChat(); }, INACTIVITY_LIMIT_MS);
  }

  function buildBrand(text){
    brand.innerHTML='';
    let i=0;
    for(const ch of text){
      const span=document.createElement('span');
      span.className='char';
      span.textContent=ch;
      span.style.setProperty('--i', String(i++));
      brand.appendChild(span);
    }
  }

  function addMsg(txt, cls){
    const div=document.createElement('div');
    div.className='chat-msg '+cls;
    div.textContent=txt;
    log.appendChild(div);
    log.scrollTop=log.scrollHeight;
  }

  function saveHistory(){
    if(!log) return;
    const msgs=[...log.querySelectorAll('.chat-msg')].map(m=>({
      cls:m.className.replace('chat-msg','').trim(),
      txt:m.textContent
    }));
    try{ sessionStorage.setItem('chatHistory', JSON.stringify(msgs)); }catch(e){}
  }

  function loadHistory(){
    try{
      const data=sessionStorage.getItem('chatHistory');
      if(!data) return;
      const msgs=JSON.parse(data);
      msgs.forEach(m=>addMsg(m.txt, m.cls));
    }catch(e){ sessionStorage.removeItem('chatHistory'); }
  }

  async function reportHoneypot(reason){
    try{
      await fetch(WORKER_HONEYPOT_URL, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ reason, ts: Date.now(), ua: navigator.userAgent })
      });
    }catch(e){}
  }
  function lockUIForHoneypot(){
    send.disabled=true;
    input.disabled=true;
    addMsg('Security: blocked due to suspicious activity.', 'bot');
    alert('Security check failed. This session has been blocked.');
  }

  function updateSendEnabled(){
    if(!send || !input) return;
    const hasText = input.value.trim().length > 0;
    send.disabled = !hasText || input.disabled;
  }

  function autoGrow(){
    input.style.height='auto';
    const maxPx=48;
    input.style.height=Math.min(input.scrollHeight, maxPx)+'px';
  }

  async function handleSubmit(e) {
    e.preventDefault();
    if (window.antibot.isHoneypotTriggered(form)) {
      reportHoneypot('honeypot_on_submit').then(lockUIForHoneypot);
      return;
    }
    const msg = input.value.trim();
    if (!msg) {
      updateSendEnabled();
      return;
    }

    addMsg(msg, 'user');
    input.value = '';
    autoGrow();
    updateSendEnabled();
    addMsg('…', 'bot');
    const botMsgElement = log.lastChild;
    try {
      const token = await window.antibot.getRecaptchaToken('chat');
      const r = await fetch(WORKER_CHAT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: msg, recaptchaToken: token })
      });
      const d = await r.json();
      botMsgElement.textContent = d.reply || 'No reply.';
    } catch (error) {
      botMsgElement.textContent = 'Error: Can’t reach AI.';
    }
    saveHistory();
  }

  async function terminateSession(){
    try{ await fetch(WORKER_END_SESSION_URL, { method:'POST' }); }catch(e){}
  }

  function clearUIState(){
    log.innerHTML='';
    input.value='';
    autoGrow();
    updateSendEnabled();
    sessionStorage.removeItem('chatHistory');
  }

  function openChat(){
    window.antibot.loadRecaptcha();
    clearTimeout(inactivityTimer);
    container.style.display='';
    container.removeAttribute('aria-hidden');
    openBtn.style.display='none';
    openBtn.classList.remove('chatbot-reopen');
    openBtn.style.bottom='';
    openBtn.style.right='';
    openBtn.setAttribute('aria-expanded','true');
    openBtn.removeEventListener('click', openChat);
    sessionStorage.setItem('chatState','open');
  }

  function positionOpenBtn(){
    if(!openBtn) return;
    const fabMain=document.querySelector('.fab-main');
    const fabContainer=fabMain?fabMain.closest('.fab-container'):null;
    if(fabMain && fabContainer){
      const fabStyles=window.getComputedStyle(fabContainer);
      const fabBottom=parseInt(fabStyles.bottom,10)||0;
      const fabRight=parseInt(fabStyles.right,10)||0;
      const fabHeight=parseInt(window.getComputedStyle(fabMain).height,10)||0;
      const fabWidth=parseInt(window.getComputedStyle(fabMain).width,10)||0;
      const btnWidth=parseInt(window.getComputedStyle(openBtn).width,10)||0;
      openBtn.style.bottom=`${fabBottom + fabHeight + 10}px`;
      openBtn.style.right=`${fabRight + (fabWidth - btnWidth) / 2}px`;
    }
  }

  function minimizeChat(){
    saveHistory();
    container.style.display='none';
    container.setAttribute('aria-hidden','true');
    openBtn.style.display='inline-flex';
    openBtn.innerHTML = 'CHAT';
    openBtn.classList.add('chatbot-reopen');
    openBtn.setAttribute('aria-expanded','false');
    openBtn.addEventListener('click', openChat, { once:true });
    sessionStorage.setItem('chatState','minimized');
    positionOpenBtn();
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(closeChat, INACTIVITY_LIMIT_MS);
  }

  function closeChat(){
    clearTimeout(inactivityTimer);
    clearUIState();
    sessionStorage.removeItem('chatState');
    terminateSession();
    document.removeEventListener('click', outsideClickHandler);
    document.removeEventListener('keydown', escKeyHandler);
    container.remove();
    if (openBtn && openBtn.remove) {
      openBtn.remove();
    }
    openBtn = null;
  }

  function initChatbot(){
    const qs = s=>document.querySelector(s), qsa=s=>[...document.querySelectorAll(s)];
    container = qs('#chatbot-container');
    if(!container) return;
    if (window.appUtils && window.appUtils.makeDraggable && window.innerWidth >= 768) {
      window.appUtils.makeDraggable(container);
      document.body.classList.add('drag-enabled');
    } else {
      document.body.classList.remove('drag-enabled');
    }
    log = qs('#chat-log');
    form = qs('#chatbot-input-grid');
    input = qs('#chatbot-input');
    send = qs('#chatbot-send');
    closeBtn = qs('#chatbot-close');
    minimizeBtn = qs('#minimizeBtn');
    openBtn = qs('#chat-open-btn');
      langCtrl = qs('#langCtrl');
      themeCtrl = qs('#themeCtrl');
      brand = qs('#brand');
      themeCtrl.textContent = (window.currentTheme === 'light') ? 'Dark' : 'Light';
    window.antibot.injectChatbotHoneypot(form);
    hpText = qs('#hp_text');
    hpCheck = qs('#hp_check');
    const transNodes = qsa('[data-en]');
    const phNodes = qsa('[data-en-ph]');

    buildBrand(brand.dataset.en || 'Ops Online Support');
    langCtrl.textContent='ES';
    langCtrl.addEventListener('click', ()=>{
      const goES = langCtrl.textContent === 'ES';
      document.documentElement.lang = goES ? 'es' : 'en';
      langCtrl.textContent = goES ? 'EN' : 'ES';
      transNodes.forEach(n => n.textContent = goES ? (n.dataset.es || n.textContent) : (n.dataset.en || n.textContent));
      phNodes.forEach(n => n.placeholder = goES ? (n.dataset.esPh || n.placeholder) : (n.dataset.enPh || n.placeholder));
      buildBrand(goES ? (brand.dataset.es || 'Soporte en Línea OPS') : (brand.dataset.en || 'Ops Online Support'));
    });
      themeCtrl.addEventListener('click', ()=>{
        const toDark = themeCtrl.textContent === 'Dark';
        window.currentTheme = toDark ? 'dark' : 'light';
        localStorage.setItem('theme', window.currentTheme);
        updateTheme();
        themeCtrl.textContent = toDark ? 'Light' : 'Dark';
      });

    input.addEventListener('input', ()=>{ autoGrow(); updateSendEnabled(); });
    input.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(!send.disabled) form.requestSubmit(); }});
    window.addEventListener('load', ()=>{ autoGrow(); updateSendEnabled(); });

    form.addEventListener('submit', handleSubmit);
    minimizeBtn.addEventListener('click', minimizeChat);
    closeBtn.addEventListener('click', closeChat);

    escKeyHandler = (e)=>{
      if(e.key === 'Escape'){
        closeChat();
      }
    };
    outsideClickHandler = (e)=>{
      if(
        container.style.display !== 'none' &&
        !container.contains(e.target) &&
        e.target !== openBtn
      ){
        minimizeChat();
      }
    };
    document.addEventListener('keydown', escKeyHandler);
    document.addEventListener('click', outsideClickHandler);
    ['change','input','click'].forEach(ev=>{
      hpText.addEventListener(ev, ()=>{ reportHoneypot('hp_text_touched'); lockUIForHoneypot(); }, { passive:true });
      hpCheck.addEventListener(ev, ()=>{ reportHoneypot('hp_check_ticked'); lockUIForHoneypot(); }, { passive:true });
    });

    // Start with chat hidden until the user explicitly opens it.
    container.style.display = 'none';
    container.setAttribute('aria-hidden', 'true');
    openBtn.style.display = 'none';
    openBtn.setAttribute('aria-expanded', 'false');
    loadHistory();
    window.addEventListener('beforeunload', saveHistory);
  }

  async function reloadChat(){
    try{
      // Remove any existing FAB or chatbot fragment before reloading to avoid
      // background overlays or duplicate floating buttons.
      if(openBtn && typeof openBtn.remove === 'function'){
        openBtn.remove();
        openBtn = null;
      }
      const existing = document.getElementById('chatbot-container');
      if(existing && typeof existing.remove === 'function'){
        existing.remove();
      }

      const res = await fetch('fabs/chatbot.html', { credentials:'same-origin' });
      const html = await res.text();
      const template = document.createElement('template');
      template.innerHTML = html;
      const frag = template.content;
      document.body.appendChild(frag);
      initChatbot();
      const state = sessionStorage.getItem('chatState');
      if(state === 'open'){
        openChat();
      }else if(state === 'minimized'){
        openBtn.style.display='inline-flex';
        openBtn.innerHTML = 'CHAT';
        openBtn.classList.add('chatbot-reopen');
        openBtn.setAttribute('aria-expanded','false');
        openBtn.addEventListener('click', openChat, { once:true });
        positionOpenBtn();
      }
    }catch(err){
      console.error('Failed to reload chatbot:', err);
    }
  }

  window.reloadChat = reloadChat;
  window.initChatbot = initChatbot;
  window.cleanupChatbot = closeChat;
  window.openChatbot = openChat;
  if (sessionStorage.getItem('chatState')) {
    window.addEventListener('DOMContentLoaded', () => { reloadChat(); });
  }
})();
```

## netlify.toml
```toml
[build]
  publish = "."

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    Referrer-Policy = "strict-origin-when-cross-origin"
    Permissions-Policy = "geolocation=(), microphone=(), camera=(), payment=(), usb=(), accelerometer=(), gyroscope=(), magnetometer=()"
    Cross-Origin-Opener-Policy = "same-origin"
    Cross-Origin-Resource-Policy = "same-origin"
    Strict-Transport-Security = "max-age=31536000; includeSubDomains; preload"
    Cache-Control = "no-store"
    Content-Security-Policy = "default-src 'self'; script-src 'self' 'sha384-JEyTNhjM6R1ElGoJns4U2Ln4ofPcqzSsynQkmEc/KGy6336qAZl70tDLufbkla+3' https://*.hcaptcha.com; style-src 'self' 'sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==' https://*.hcaptcha.com; img-src 'self' data: https://*.hcaptcha.com; font-src 'self' https://cdnjs.cloudflare.com; connect-src 'self' https://*.workers.dev https://*.hcaptcha.com; frame-src https://*.hcaptcha.com; frame-ancestors 'none'; form-action 'self'; base-uri 'none'; object-src 'none'; require-trusted-types-for 'script'; upgrade-insecure-requests"
[[headers]]
  for = "/*.css"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.js"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.woff2"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.png"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.jpg"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.svg"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/.well-known/security.txt"
  [headers.values]
    Content-Type = "text/plain; charset=utf-8"
    X-Content-Type-Options = "nosniff"
    Cache-Control = "public, max-age=86400"
```

## tests/join-form.test.js
```javascript
const test = require('node:test');
const assert = require('node:assert');
const { JSDOM } = require('jsdom');
const fs = require('fs');
const path = require('path');
const antibotJs = fs.readFileSync(path.resolve(__dirname, '../js/antibot.js'), 'utf8');
const hpHtml = fs.readFileSync(path.resolve(__dirname, '../security/honeypots.html'), 'utf8');
const utilsJs = fs.readFileSync(path.resolve(__dirname, '../js/utils.js'), 'utf8');

// Helper function to set up the DOM and load the script
function setupTestEnvironment(html) {
  const dom = new JSDOM(html, { runScripts: 'outside-only' });
  const { window } = dom;

  // Mock necessary browser APIs
  window.alert = () => {};
  window.fetch = (url) => {
    if (url && url.includes('security/honeypots.html')) {
      return Promise.resolve({ ok: true, text: async () => hpHtml });
    }
    return Promise.resolve({ ok: true, json: async () => ({}) });
  };
  window.grecaptcha = { ready: cb => cb(), execute: async () => 'token' };
  window.eval(utilsJs);
  window.eval(antibotJs);

  // Load the script into the JSDOM context
  const cojoinScript = fs.readFileSync(path.resolve(__dirname, '../fabs/js/cojoin.js'), 'utf8');
  window.eval(cojoinScript);

  // Trigger DOMContentLoaded to run the script's initialization
  window.document.dispatchEvent(new window.Event('DOMContentLoaded'));

  return dom;
}

test('Experience section adds numbered textareas', () => {
  const html = `
    <form id="joinForm">
      <div class="form-section" data-section="Experience">
        <div class="section-header">
          <h2>Experience</h2>
          <div>
            <button type="button" class="circle-btn add" title="Add field">+</button>
            <button type="button" class="circle-btn remove" title="Remove last field">−</button>
          </div>
        </div>
        <div class="inputs"></div>
        <button type="button" class="accept-btn">Accept</button>
        <button type="button" class="edit-btn" style="display:none;">Edit</button>
      </div>
    </form>
  `;
  const dom = setupTestEnvironment(html);
  const { document } = dom.window;

  const addBtn = document.querySelector('.form-section[data-section="Experience"] .circle-btn.add');
  addBtn.click();
  addBtn.click();

  const placeholders = [...document.querySelectorAll('.form-section[data-section="Experience"] textarea')].map(el => el.placeholder);
  assert.deepStrictEqual(placeholders, ['tell us about your Experience 1', 'tell us about your Experience 2']);
});

test('Continued Education section adds textarea with specific placeholder', () => {
  const html = `
    <form id="joinForm">
      <div class="form-section" data-section="Continued Education">
        <div class="section-header">
          <h2>Continued Education</h2>
          <div>
            <button type="button" class="circle-btn add" title="Add field">+</button>
            <button type="button" class="circle-btn remove" title="Remove last field">−</button>
          </div>
        </div>
        <div class="inputs"></div>
        <button type="button" class="accept-btn">Accept</button>
        <button type="button" class="edit-btn" style="display:none;">Edit</button>
      </div>
    </form>
  `;
  const dom = setupTestEnvironment(html);
  const { document } = dom.window;

  const addBtn = document.querySelector('.form-section[data-section="Continued Education"] .circle-btn.add');
  addBtn.click();

  const textarea = document.querySelector('.form-section[data-section="Continued Education"] textarea');
  assert.strictEqual(textarea.placeholder, 'Online Courses, Seminars, Webinars with Completion Certification');
});

## tests/chatbot-modal.test.js
```javascript
const test = require('node:test');
const assert = require('node:assert');
const { JSDOM } = require('jsdom');
const fs = require('node:fs');
const path = require('node:path');
const htmlPath = path.join(__dirname, '..', 'fabs', 'chatbot.html');
const jsPath = path.join(__dirname, '..', 'fabs', 'js', 'chattia.js');
const dragJsPath = path.join(__dirname, '..', 'fabs', 'js', 'cojoin.js');
const cssPath = path.join(__dirname, '..', 'fabs', 'css', 'chatbot.css');
const html = fs.readFileSync(htmlPath, 'utf8');
const script = fs.readFileSync(jsPath, 'utf8');
const dragScript = fs.readFileSync(dragJsPath, 'utf8');
const style = fs.readFileSync(cssPath, 'utf8');
const antibotJs = fs.readFileSync(path.join(__dirname, '..', 'js', 'antibot.js'), 'utf8');
const hpHtml = fs.readFileSync(path.join(__dirname, '..', 'security', 'honeypots.html'), 'utf8');
const utilsJs = fs.readFileSync(path.join(__dirname, '..', 'js', 'utils.js'), 'utf8');
const langThemeJs = fs.readFileSync(path.join(__dirname, '..', 'js', 'langtheme.js'), 'utf8');
test('Chattia chatbot basic interactions', async () => {
  const dom = new JSDOM(`<body></body>`, { url: 'https://example.com', runScripts: 'dangerously' });
  const { window } = dom;
  const document = window.document;
  window.innerWidth = 1024;
  const styleEl = document.createElement('style');
  styleEl.textContent = style;
  document.head.appendChild(styleEl);
  window.fetch = async (url, opts) => {
    if (url && url.includes('chatbot.html')) {
      return { text: async () => html };
    }
    if (url && url.includes('security/honeypots.html')) {
      return { ok: true, text: async () => hpHtml };
    }
    if (url && url.includes('honeypot')) {
      return {};
    }
    if (url && url.includes('end-session')) {
      return {};
    }
    return { json: async () => ({ reply: 'ok' }) };
  };

  window.alert = () => {};
  window.grecaptcha = { ready: cb => cb(), execute: async () => 'token' };
    window.eval(utilsJs);
    window.eval(antibotJs);
    window.eval(langThemeJs);
    window.eval(dragScript);
    window.eval(script);
  await window.reloadChat();
  window.openChatbot();
  const brand = document.getElementById('brand');
  assert.ok(brand.querySelectorAll('.char').length > 0);
  const langCtrl = document.getElementById('langCtrl');
  const input = document.getElementById('chatbot-input');
  langCtrl.click();
  assert.strictEqual(document.documentElement.lang, 'es');
  langCtrl.click();
  assert.strictEqual(document.documentElement.lang, 'en');
  const themeCtrl = document.getElementById('themeCtrl');
    themeCtrl.click();
    assert.ok(document.documentElement.classList.contains('dark'));
    themeCtrl.click();
    assert.ok(!document.documentElement.classList.contains('dark'));
  const send = document.getElementById('chatbot-send');
  assert.ok(send.disabled);
  input.value = 'Hi';
  input.dispatchEvent(new window.Event('input', { bubbles: true }));
  assert.ok(!send.disabled);

  // honeypot triggers lock
  let alerted = false;
  window.alert = () => { alerted = true; };
  document.getElementById('hp_check').dispatchEvent(new window.Event('click', { bubbles: true }));
  assert.ok(alerted);
  assert.ok(send.disabled);

  // start fresh session
  document.querySelectorAll('#chatbot-container').forEach(el => el.remove());
  document.querySelectorAll('#chat-open-btn').forEach(el => el.remove());
  await window.reloadChat();
  window.openChatbot();
  const minimizeBtn = document.getElementById('minimizeBtn');
  const container = document.getElementById('chatbot-container');
  const openBtn = document.getElementById('chat-open-btn');
  const header = document.getElementById('chatbot-header');
  assert.ok(document.body.classList.contains('drag-enabled'));
  container.style.left = '0px';
  container.style.top = '0px';
  header.dispatchEvent(new window.MouseEvent('mousedown', { clientX: 10, clientY: 10, bubbles: true }));
  document.dispatchEvent(new window.MouseEvent('mousemove', { clientX: 30, clientY: 30, bubbles: true }));
  document.dispatchEvent(new window.MouseEvent('mouseup', { bubbles: true }));
  assert.notStrictEqual(container.style.left, '0px');
  assert.notStrictEqual(container.style.top, '0px');
  minimizeBtn.click();
  assert.strictEqual(container.style.display, 'none');
  openBtn.click();
  assert.strictEqual(container.style.display, '');

  // message persists across reloads
  window.grecaptcha = { ready: cb => cb(), execute: async () => 'token' };
  const recaptchaScript = document.getElementById('recaptcha-script');
  if (recaptchaScript && recaptchaScript.onload) recaptchaScript.onload();
  const form = document.getElementById('chatbot-input-grid');
  const input2 = document.getElementById('chatbot-input');
  input2.value = 'Hello';
  input2.dispatchEvent(new window.Event('input', { bubbles: true }));
  form.dispatchEvent(new window.Event('submit', { bubbles: true, cancelable: true }));
  await new Promise(r => setTimeout(r,0));
  document.querySelectorAll('#chatbot-container').forEach(el => el.remove());
  document.querySelectorAll('#chat-open-btn').forEach(el => el.remove());
  await window.reloadChat();
  const logText = document.getElementById('chat-log').textContent;
  assert.ok(logText.includes('Hello'));
  const closeBtn = document.getElementById('chatbot-close');
  closeBtn.click();
  assert.strictEqual(document.getElementById('chatbot-container'), null);
});

```

## worker/nonceWorker.js
_Sourced from `worker/nonceWorker.js`; original file retained for operational use._
```javascript
export default {
  async fetch(request, env) {
    if (request.method !== 'POST') {
      return new Response('Method Not Allowed', { status: 405 });
    }

    let nonce;
    try {
      ({ nonce } = await request.json());
    } catch (err) {
      return new Response('Bad Request', { status: 400 });
    }
    if (!nonce) {
      return new Response('Bad Request', { status: 400 });
    }

    const exists = await env.USED_NONCES.get(nonce);
    if (exists) {
      return new Response(JSON.stringify({ error: 'nonce-reused' }), {
        status: 409,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    await env.USED_NONCES.put(nonce, '1', { expirationTtl: 86400 });
    return new Response(JSON.stringify({ ok: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  }
};

```

## tests/bundle.js
_Sourced from `tests/bundle.js`; original file retained for runtime tests._
```javascript
// Auto-generated test bundle for Cloudflare Worker
// Each function dynamically imports a test module.
export default [
  async function assetsFunctionsTest() {
    await import('./assets-functions.test.js');
  },
  async function chatbotModalTest() {
    await import('./chatbot-modal.test.js');
  },
  async function cardsLearnMoreTest() {
    await import('./cards-learn-more.test.js');
  },
  async function footerTest() {
    await import('./footer.test.js');
  },
  async function joinFormTest() {
    await import('./join-form.test.js');
  },
  async function mobileNavTest() {
    await import('./mobile-nav.test.js');
  },
  async function securityHeadersTest() {
    await import('./security-headers.test.js');
  }
];

```
