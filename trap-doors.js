/* Source: fabs/js/cojoin.js */
/**
 * fabs/js/cojoin.js
 *
 * This script contains the logic for both the Contact Us and Join Us forms.
 * It handles form submission, security checks (honeypot, malicious code),
 * and the dynamic form fields for the Join form.
 */

function initCojoinForms() {

  const contactForm = document.getElementById('contactForm');
  const joinForm = document.getElementById('joinForm');

  if (contactForm && !contactForm.dataset.cojoinInitialized) {
    contactForm.addEventListener('submit', handleContactSubmit);
    contactForm.dataset.cojoinInitialized = 'true';
  }

  if (joinForm && !joinForm.dataset.cojoinInitialized) {
    joinForm.addEventListener('submit', handleJoinSubmit);
    joinForm.dataset.cojoinInitialized = 'true';
    initJoinForm();
  }


  /**
   * Retrieves an AES-GCM key generated by a server-side KMS/HSM.
   * The server is responsible for managing the lifecycle of this key
   * in alignment with NIST and PCI DSS requirements.
   * @returns {Promise<CryptoKey>} The imported AES-GCM key.
   */
  async function getAesKeyFromKms() {
    // ====================================================================================
    // IMPORTANT: AES Key Service Endpoint
    // Replace the URL below with your actual endpoint for fetching the AES key.
    // ====================================================================================
    const res = await fetch('https://your-server.example.com/kms/aes-key');
    const { key } = await res.json(); // base64 encoded key material
    const rawKey = base64ToArrayBuffer(key);
    return crypto.subtle.importKey('raw', rawKey, { name: 'AES-GCM' }, false, ['encrypt']);
  }

  /**
   * Requests a short-lived bearer token from the server. The token is
   * returned as an AES-GCM encrypted blob alongside its IV so it can be
   * decrypted by the Cloudflare worker.
   * @returns {Promise<{token: string, iv: string}>}
   */
  async function getBearerToken() {
    // ====================================================================================
    // IMPORTANT: Auth Token Service Endpoint
    // Replace the URL below with your actual endpoint for fetching the auth token.
    // ====================================================================================
    const res = await fetch('https://your-server.example.com/auth/token');
    return res.json(); // { token: base64CipherText, iv: base64IV }
  }

  function arrayBufferToBase64(buffer) {
    return btoa(String.fromCharCode(...new Uint8Array(buffer)));
  }

  function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  /**
   * Simulated function to send data to a Cloudflare worker.
   * This is where you would implement your data encryption logic before sending.
   * @param {object} data The sanitized form data to send.
   */
  async function sendToCloudflareWorker(data) {
    console.log("Data is clean. Encrypting and sending to Cloudflare worker...", data);
    try {
      // Retrieve managed key and short-lived token from the server
      const [aesKey, tokenInfo] = await Promise.all([
        getAesKeyFromKms(),
        getBearerToken(),
      ]);

      // Encrypt payload using AES-GCM
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoder = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        aesKey,
        encoder.encode(JSON.stringify(data))
      );

      const payload = {
        iv: Array.from(iv),
        payload: arrayBufferToBase64(encrypted),
      };

      // Compose Authorization header as Bearer <iv>.<cipher>
      const authHeader = `Bearer ${tokenInfo.iv}.${tokenInfo.token}`;

      // ====================================================================================
      // IMPORTANT: Cloudflare Worker API Endpoint
      // Replace the URL below with your actual Cloudflare Worker API endpoint.
      // ====================================================================================
      const response = await fetch('https://your-cloudflare-worker.example.com/api', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': authHeader,
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        console.log('Data successfully sent and processed by Cloudflare worker.');
      } else {
        console.error('Failed to send data to Cloudflare worker.');
      }
    } catch (error) {
      console.error('Network error or worker unreachable:', error);
    }
  }

  /**
   * Contact Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleContactSubmit(e) {
    e.preventDefault();

    // 1. Honeypot check: Block if this hidden field is filled
    const honeypotField = document.getElementById('honeypot-contact');
    if (honeypotField && honeypotField.value !== '') {
      console.warn('Honeypot filled. Blocking form submission.');
      e.target.reset(); // Reset form to clear any malicious data
      return;
    }

    const form = e.target;
    const formData = new FormData(form);

    // 2. hCaptcha check
    const hCaptchaResponse = formData.get('h-captcha-response');
    if (!hCaptchaResponse) {
      alert('Please complete the hCaptcha challenge.');
      // NOTE: In a real-world scenario, we might want to trigger a reset
      // of the captcha widget here, but for now, an alert is sufficient.
      return;
    }

    const data = Object.fromEntries(formData.entries());

    // 3. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = window.appUtils.sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }
    
    // 3. Prepare and send sanitized data to worker
    alert('Contact form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Join Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleJoinSubmit(e) {
    e.preventDefault();

    // 1. Honeypot check
    const honeypotField = document.getElementById('honeypot-join');
    if (honeypotField && honeypotField.value !== '') {
      console.warn('Honeypot filled. Blocking form submission.');
      e.target.reset();
      return;
    }

    const form = e.target;
    const formData = new FormData(form);

    // 2. hCaptcha check
    const hCaptchaResponse = formData.get('h-captcha-response');
    if (!hCaptchaResponse) {
      alert('Please complete the hCaptcha challenge.');
      return;
    }

    const data = Object.fromEntries(formData.entries());

    // Check that all dynamic sections are 'accepted' or empty
    const formSections = document.querySelectorAll('.form-section[data-section]');
    for (const section of formSections) {
      const inputs = section.querySelectorAll('input[type=text]');
      if (inputs.length > 0 && !section.classList.contains('completed')) {
        alert(`Please accept your entries in "${section.querySelector('h2').textContent}" or remove them.`);
        return;
      }
    }

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = window.appUtils.sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }

    // 3. Prepare and send sanitized data to worker
    alert('Join form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    resetJoinFormState();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Initializes event listeners for the Join Us form's dynamic sections.
   */
  function initJoinForm() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      const addBtn = section.querySelector('.circle-btn.add');
      const removeBtn = section.querySelector('.circle-btn.remove');
      const acceptBtn = section.querySelector('.accept-btn');
      const editBtn = section.querySelector('.edit-btn');
      const inputsContainer = section.querySelector('.inputs');

      if (addBtn) {
        addBtn.addEventListener('click', () => {
          let field;
          if (section.dataset.section === 'Experience') {
            const count = inputsContainer.querySelectorAll('textarea').length + 1;
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = `tell us about your Experience ${count}`;
          } else if (section.dataset.section === 'Continued Education') {
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = 'Online Courses, Seminars, Webinars with Completion Certification';
          } else {
            field = document.createElement('input');
            field.type = 'text';
            field.placeholder = `Enter ${section.querySelector('h2').textContent.toLowerCase()}`;
          }
          inputsContainer.appendChild(field);
          field.focus();
        });
      }

      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          if (!section.classList.contains('completed')) {
            if (inputsContainer.lastElementChild) {
              inputsContainer.removeChild(inputsContainer.lastElementChild);
            }
          }
        });
      }

      if (acceptBtn) {
        acceptBtn.addEventListener('click', () => {
          const inputs = inputsContainer.querySelectorAll('input[type=text], textarea');
          if (inputs.length === 0) {
            alert('Add at least one entry.');
            return;
          }
          for (const input of inputs) {
            if (!input.value.trim()) {
              alert('Please fill out all fields before accepting.');
              return;
            }
          }
          toggleSectionState(section, true);
        });
      }

      if (editBtn) {
        editBtn.addEventListener('click', () => {
          toggleSectionState(section, false);
        });
      }
    });
  }

  /**
   * Resets the Join Us form to its initial state after submission.
   */
  function resetJoinFormState() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      toggleSectionState(section, false);
      const inputsContainer = section.querySelector('.inputs');
      inputsContainer.innerHTML = '';
    });
  }

  /**
   * Toggles the state of a dynamic form section (accepted/editable).
   * @param {HTMLElement} section The form section element.
   * @param {boolean} accepted True to lock the section, false to unlock.
   */
  function toggleSectionState(section, accepted) {
    const inputs = section.querySelectorAll('input[type=text], textarea');
    const acceptBtn = section.querySelector('.accept-btn');
    const editBtn = section.querySelector('.edit-btn');
    const addBtn = section.querySelector('.circle-btn.add');
    const removeBtn = section.querySelector('.circle-btn.remove');

    inputs.forEach(input => input.disabled = accepted);

    if (accepted) {
      if (acceptBtn) acceptBtn.style.display = 'none';
      if (editBtn) editBtn.style.display = 'inline-block';
      if (addBtn) addBtn.disabled = true;
      if (removeBtn) removeBtn.disabled = true;
      section.classList.add('completed');
    } else {
      if (acceptBtn) acceptBtn.style.display = 'inline-block';
      if (editBtn) editBtn.style.display = 'none';
      if (addBtn) addBtn.disabled = false;
      if (removeBtn) removeBtn.disabled = false;
      section.classList.remove('completed');
    }
  }
}

window.initCojoinForms = initCojoinForms;
document.addEventListener('DOMContentLoaded', initCojoinForms);

/* Source: fabs/js/chattia.js */
(function(){
  const WORKER_CHAT_URL = 'https://your-cloudflare-worker.example.com/chat';
  const WORKER_END_SESSION_URL = 'https://your-cloudflare-worker.example.com/end-session';
  const WORKER_HONEYPOT_URL = 'https://your-cloudflare-worker.example.com/honeypot-trip';
  let container, log, form, input, send, closeBtn, minimizeBtn, openBtn;
  let langCtrl, themeCtrl, brand, hpText, hpCheck;
  let hCaptchaWidgetID; // To store the ID of the invisible hCaptcha widget
  let outsideClickHandler, escKeyHandler, inactivityTimer;
  function resetInactivityTimer(){
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(()=>{ closeChat(); }, 120000);
  }

  function buildBrand(text){
    brand.innerHTML='';
    let i=0;
    for(const ch of text){
      const span=document.createElement('span');
      span.className='char';
      span.textContent=ch;
      span.style.setProperty('--i', String(i++));
      brand.appendChild(span);
    }
  }

  function addMsg(txt, cls){
    const div=document.createElement('div');
    div.className='chat-msg '+cls;
    div.textContent=txt;
    log.appendChild(div);
    log.scrollTop=log.scrollHeight;
  }

  async function reportHoneypot(reason){
    try{
      await fetch(WORKER_HONEYPOT_URL, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ reason, ts: Date.now(), ua: navigator.userAgent })
      });
    }catch(e){}
  }
  function lockUIForHoneypot(){
    send.disabled=true;
    input.disabled=true;
    addMsg('Security: blocked due to suspicious activity.', 'bot');
    alert('Security check failed. This session has been blocked.');
  }

  function updateSendEnabled(){
    if(!send || !input) return;
    const hasText = input.value.trim().length > 0;
    send.disabled = !hasText || input.disabled;
  }

  function autoGrow(){
    input.style.height='auto';
    const maxPx=48;
    input.style.height=Math.min(input.scrollHeight, maxPx)+'px';
  }

  function handleSubmit(e) {
    e.preventDefault();
    if (hpText.value.trim() !== '' || hpCheck.checked) {
      reportHoneypot('honeypot_on_submit').then(lockUIForHoneypot);
      return;
    }
    const msg = input.value.trim();
    if (!msg) {
      updateSendEnabled();
      return;
    }

    addMsg(msg, 'user');
    input.value = '';
    autoGrow();
    updateSendEnabled();
    addMsg('…', 'bot');

    const botMsgElement = log.lastChild;

    const onHcaptchaSuccess = (token) => {
      fetch(WORKER_CHAT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: msg, 'h-captcha-response': token }),
      })
        .then((r) => r.json())
        .then((d) => {
          botMsgElement.textContent = d.reply || 'No reply.';
          saveHistory();
        })
        .catch(() => {
          botMsgElement.textContent = 'Error: Can’t reach AI.';
          saveHistory();
        });
    };

    const onHcaptchaClose = () => {
      botMsgElement.textContent = 'Security check cancelled.';
      saveHistory();
    };

    // Execute hCaptcha
    if (window.hcaptcha && hCaptchaWidgetID) {
      try {
        window.hcaptcha.execute(hCaptchaWidgetID, {
          callback: onHcaptchaSuccess,
          'error-callback': onHcaptchaClose,
          'close-callback': onHcaptchaClose,
        });
      } catch (error) {
        console.error("hCaptcha execution error:", error);
        onHcaptchaClose();
      }
    } else {
      botMsgElement.textContent = 'Error: Could not initialize security check.';
      saveHistory();
    }
  }

  async function terminateSession(){
    try{ await fetch(WORKER_END_SESSION_URL, { method:'POST' }); }catch(e){}
  }

  function clearUIState(){
    log.innerHTML='';
    input.value='';
    autoGrow();
    updateSendEnabled();
  }

  function openChat(){
    clearTimeout(inactivityTimer);
    container.style.display='';
    container.removeAttribute('aria-hidden');
    openBtn.style.display='none';
    openBtn.classList.remove('chatbot-reopen');
    openBtn.style.bottom='';
    openBtn.style.right='';
    openBtn.setAttribute('aria-expanded','true');
    openBtn.removeEventListener('click', openChat);
  }

  function minimizeChat(){
    saveHistory();
    container.style.display='none';
    container.setAttribute('aria-hidden','true');
    openBtn.style.display='inline-flex';
    openBtn.innerHTML = '<span class="material-symbols-outlined">chat_bubble</span>';
    openBtn.classList.add('chatbot-reopen');
    openBtn.setAttribute('aria-expanded','false');
    openBtn.addEventListener('click', openChat, { once:true });
    const fabMain = document.querySelector('.fab-main');
    const fabContainer = fabMain ? fabMain.closest('.fab-container') : null;
    if (fabMain && fabContainer) {
      const fabStyles = window.getComputedStyle(fabContainer);
      const fabBottom = parseInt(fabStyles.bottom, 10) || 0;
      const fabRight = parseInt(fabStyles.right, 10) || 0;
      const fabHeight = parseInt(window.getComputedStyle(fabMain).height, 10) || 0;
      const fabWidth = parseInt(window.getComputedStyle(fabMain).width, 10) || 0;
      const btnWidth = parseInt(window.getComputedStyle(openBtn).width, 10) || 0;
      openBtn.style.bottom = `${fabBottom + fabHeight + 10}px`;
      openBtn.style.right = `${fabRight + (fabWidth - btnWidth) / 2}px`;
    }
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(closeChat, INACTIVITY_LIMIT_MS);
  }

  function closeChat(){
    clearTimeout(inactivityTimer);
    clearUIState();
    terminateSession();
    document.removeEventListener('click', outsideClickHandler);
    document.removeEventListener('keydown', escKeyHandler);
    container.remove();
    if (openBtn && openBtn.remove) {
      openBtn.remove();
    }
    openBtn = null;
  }

  function initChatbot(){
    const qs = s=>document.querySelector(s), qsa=s=>[...document.querySelectorAll(s)];
    container = qs('#chatbot-container');
    if(!container) return;
    if (window.appUtils && window.appUtils.makeDraggable && window.innerWidth >= 768) {
      window.appUtils.makeDraggable(container);
      document.body.classList.add('drag-enabled');
    } else {
      document.body.classList.remove('drag-enabled');
    }
    log = qs('#chat-log');
    form = qs('#chatbot-input-grid');
    input = qs('#chatbot-input');
    send = qs('#chatbot-send');
    closeBtn = qs('#chatbot-close');
    minimizeBtn = qs('#minimizeBtn');
    openBtn = qs('#chat-open-btn');
    langCtrl = qs('#langCtrl');
    themeCtrl = qs('#themeCtrl');
    brand = qs('#brand');
    hpText = qs('#hp_text');
    hpCheck = qs('#hp_check');
    const transNodes = qsa('[data-en]');
    const phNodes = qsa('[data-en-ph]');

    buildBrand(brand.dataset.en || 'Ops Online Support');
    langCtrl.textContent='ES';
    langCtrl.addEventListener('click', ()=>{
      const goES = langCtrl.textContent === 'ES';
      document.documentElement.lang = goES ? 'es' : 'en';
      langCtrl.textContent = goES ? 'EN' : 'ES';
      transNodes.forEach(n => n.textContent = goES ? (n.dataset.es || n.textContent) : (n.dataset.en || n.textContent));
      phNodes.forEach(n => n.placeholder = goES ? (n.dataset.esPh || n.placeholder) : (n.dataset.enPh || n.placeholder));
      buildBrand(goES ? (brand.dataset.es || 'Soporte en Línea OPS') : (brand.dataset.en || 'Ops Online Support'));
    });
    themeCtrl.addEventListener('click', ()=>{
      const toDark = themeCtrl.textContent === 'Dark';
      document.body.classList.toggle('dark', toDark);
      themeCtrl.textContent = toDark ? 'Light' : 'Dark';
    });

    input.addEventListener('input', ()=>{ autoGrow(); updateSendEnabled(); });
    input.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(!send.disabled) form.requestSubmit(); }});
    window.addEventListener('load', ()=>{ autoGrow(); updateSendEnabled(); });

    form.addEventListener('submit', handleSubmit);
    minimizeBtn.addEventListener('click', minimizeChat);
    closeBtn.addEventListener('click', closeChat);

    escKeyHandler = (e)=>{
      if(e.key === 'Escape'){
        closeChat();
      }
    };
    outsideClickHandler = (e)=>{
      if(
        container.style.display !== 'none' &&
        !container.contains(e.target) &&
        e.target !== openBtn
      ){
        minimizeChat();
      }
    };
    document.addEventListener('keydown', escKeyHandler);
    document.addEventListener('click', outsideClickHandler);
    ['change','input','click'].forEach(ev=>{
      hpText.addEventListener(ev, ()=>{ reportHoneypot('hp_text_touched'); lockUIForHoneypot(); }, { passive:true });
      hpCheck.addEventListener(ev, ()=>{ reportHoneypot('hp_check_ticked'); lockUIForHoneypot(); }, { passive:true });
    });

    // Start with chat hidden until the user explicitly opens it.
    container.style.display = 'none';
    container.setAttribute('aria-hidden', 'true');
    openBtn.style.display = 'inline-flex';
    openBtn.setAttribute('aria-expanded', 'false');
    openBtn.addEventListener('click', openChat, { once: true });
    loadHistory();
    renderHcaptcha();
  }

  function renderHcaptcha() {
    const captchaDiv = document.getElementById('chatbot-hcaptcha');
    if (captchaDiv && window.hcaptcha && typeof window.hcaptcha.render === 'function') {
      hCaptchaWidgetID = window.hcaptcha.render(captchaDiv, {
        sitekey: '10000000-ffff-ffff-ffff-000000000001', // Test key
        size: 'invisible',
      });
    } else {
      // If hcaptcha API isn't ready, try again shortly.
      setTimeout(renderHcaptcha, 500);
    }
  }

  async function reloadChat(){
    try{
      // Remove any existing FAB or chatbot fragment before reloading to avoid
      // background overlays or duplicate floating buttons.
      if(openBtn && typeof openBtn.remove === 'function'){
        openBtn.remove();
        openBtn = null;
      }
      const existing = document.getElementById('chatbot-container');
      if(existing && typeof existing.remove === 'function'){
        existing.remove();
      }

      const res = await fetch('fabs/chatbot.html', { credentials:'same-origin' });
      const html = await res.text();
      const template = document.createElement('template');
      template.innerHTML = html;
      const frag = template.content;
      document.body.appendChild(frag);
      initChatbot();
      minimizeChat();
    }catch(err){
      console.error('Failed to reload chatbot:', err);
    }
  }

  window.reloadChat = reloadChat;
  window.initChatbot = initChatbot;
  window.cleanupChatbot = closeChat;
  window.openChatbot = openChat;
})();

/* Source: worker/secureWorker.js (verifyCaptcha) */
/**
 * Verifies the hCaptcha token by sending it to the hCaptcha API.
 * @param {string} token The hCaptcha token from the client.
 * @param {string} secret The hCaptcha secret key from environment variables.
 * @returns {Promise<boolean>} True if the token is valid, false otherwise.
 */
async function verifyCaptcha(token, secret) {
  if (!token) {
    console.warn('CAPTCHA verification failed: No token provided.');
    return false;
  }
  if (!secret) {
    console.error('FATAL: HCAPTCHA_SECRET_KEY is not set in worker environment.');
    // In a real scenario, this should trigger an alert for the admin.
    return false;
  }

  const formData = new URLSearchParams();
  formData.append('secret', secret);
  formData.append('response', token);
  // formData.append('remoteip', remoteIp); // Optional: pass user's IP

  try {
    const response = await fetch('https://api.hcaptcha.com/siteverify', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: formData,
    });

    const result = await response.json();
    if (!result.success) {
      console.warn('CAPTCHA verification failed:', result['error-codes']);
    }
    return result.success;
  } catch (error) {
    console.error('Error during hCaptcha verification request:', error);
    return false;
  }
